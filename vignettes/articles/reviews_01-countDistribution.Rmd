---
title: "Count distributions"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```
Examples of negative binomial distributions with different parameters leading to restricted and unrestricted ROC curves for different parametrizations. 

```{r setup}
options(warn = 1)
library(restrictedROC)
main_plotname <- "res/paper/countDistribution"
dir.create("res/paper", recursive = TRUE)
```

From `stats::qnbinom`:

An alternative parametrization (often used in ecology) is by the mean ``mu`` (see above), and size, the dispersion parameter, where ``prob = size/(size+mu)``. The ``variance`` is ``mu + mu^2/size`` in this parametrization.
```{r, fig.fullwidth=TRUE, fig.width=5, fig.height=5}
n_samples_per_group <- 50 # In publication: 2500
var_alternative <- function(mu, size) {
    return(mu + mu**2 / size)
}
text_parameters <- function(mu, size) {
    sprintf(
        "Mean = %5.1f, Size=%5.3f, Variance: %5.1f",
        mu, size, var_alternative(mu, size)
    )
}

current_sim <- function(dists) {
    restrictedROC::sim(dists, do_melt = FALSE, length.out = n_samples_per_group)
}

# From Ecological Models and Data in R, p. 165: In similar, but own words:
# In a negative binomial model with mean m and overdispersion k, smaller
# k means more heterogeneity. The variance of the negative binomial distribution is m + m^2/k.
# And so as k becomes large, the variance approaches m, and the negative binomial
# approaches the Poisson distribution. For k>10, the negative binomial is
# often indistinguishable from the Poisson distribution.
# In ecological applications, k is usually < 1.

# The "ecological" parameterization of the negative binomial replaces the
# parameters p (probability of success per trial: prob in R) and n (number of
# successes before you stop counting failures: size in R) with µ = n(1−p)/p,
# the mean number of failures expected (or of counts in a sample: mu in R),
# and k, which is typically called an overdispersion parameter. Confusingly,
# k is also called size in R, because it is mathematically equivalent to n in
# the failure-process parameterization.



# Set a log2 fold-change of 2.5: log2(625/100) == 2.5
pdf(paste0(main_plotname, "_examples.pdf"), width = 5.5, height = 5.5)
for (list_size_mus in list(
    list(size = c(1, 1), mu = c(625, 100)),
    list(size = c(.25, .25), mu = c(625, 100)),
    list(size = c(.1, .1), mu = c(625, 100)),
    list(size = c(.05, .05), mu = c(625, 100)),
    list(size = c(.05, .07), mu = c(625, 100)),
    list(size = c(.1, .05), mu = c(625, 100))
)
) {
    with_without_log <- function(x) {
        log2(x + 1)
    }
    s1 <- list_size_mus[["size"]][[1]]
    s2 <- list_size_mus[["size"]][[2]]
    m1 <- list_size_mus[["mu"]][[1]]
    m2 <- list_size_mus[["mu"]][[2]]

    set.seed(91387)
    sim_x <- current_sim(
        list(
            "positive" = function(length.out) {
                with_without_log(rnbinom(length.out, size = s1, mu = m1))
            },
            "negative" = function(length.out) {
                with_without_log(rnbinom(length.out, size = s2, mu = m2))
            }
        )
    )

    plots_rroc_way_x <- restrictedROC::plot_density_rROC_empirical(
        values_grouped = sim_x,
        direction = "<",
        positive_label = "positive"
    )
    print(plots_rroc_way_x[["single_rROC"]][["max_total"]])

    print(
        plots_rroc_way_x[["plots"]] +
            ggplot2::theme(legend.position = "none") +
            patchwork::plot_annotation(
                subtitle = paste0(text_parameters(m1, s1), "\n", text_parameters(m2, s2))
            )
    )
}
dev.off()
```

```{r, Establish realistic parameters for the negative binomial distribution}
# From https://www.reneshbedre.com/blog/deseq2.html
# load library
# DESeq2 version 1.34.0
pacman::p_load("DESeq2")

# get count dataset
count_matrix <- as.matrix(read.csv("https://reneshbedre.github.io/assets/posts/gexp/df_sc.csv", row.names = "gene"))
# view first two rows
head(count_matrix, 2)
# drop length column
count_matrix <- count_matrix[, -7]
head(count_matrix, 2)
coldata <- data.frame(
    sample = c("ctr1", "ctr2", "ctr3", "trt1", "trt2", "trt3"),
    condition = c("control", "control", "control", "infected", "infected", "infected"),
    row.names = "sample"
)
coldata$condition <- as.factor(coldata$condition)

dds <- DESeqDataSetFromMatrix(
    countData = count_matrix, colData = coldata,
    design = ~condition
)

# Remove genes with low counts
dds <- dds[rowSums(counts(dds)) >= 10, ]

# set control condition as reference
dds$condition <- relevel(dds$condition, ref = "control")
dds_ctrl <- dds[, "control" == colData(dds)$condition]
dds_inf <- dds[, "infected" == colData(dds)$condition]

dds_results <- lapply(list("full" = dds, "ctrl" = dds_ctrl, "infected" = dds_inf), function(x) {
    DESeq2::design(x) <- as.formula("~ 1")
    x <- DESeq2::estimateSizeFactors(x)
    x <- DESeq2::estimateDispersions(x)
    return(x)
})
dds_results_dispersions <- tibble::as_tibble(sapply(dds_results, DESeq2::dispersions))
pdf("removeme.pdf")
boxplot(rnbinom(100, mu = rep(c(5, 100), each = 50), size = 1 / .1) ~ factor(rep(1:2, each = 50)))
dev.off()
print(summary(DESeq2::dispersions(dds_results[[1]])))
dds_res <- DESeq(dds)

str(results(dds_res))
str(dds_res)
dds_res$dispModelMatrix
print(
    apply(assays(dds_res)[["mu"]], 2, summary) |>
        as.data.frame() |>
        tibble::rownames_to_column() |>
        tibble::as_tibble()
)

print(summary(dispersions(dds_res)))
log(700 / 100)
```
