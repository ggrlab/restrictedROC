---
title: "Datatypes 02: Metabolomics"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```




```{r setup}
options(warn = 1)
library(restrictedROC)
```

```{r, Use dataMelanoma}
library(dplyr)
outdir <- "intermediate_data/li-2019"
dir.create(outdir)
li_all_data_measurements <- dataMelanoma::li2019_measurements
```

```{r, ttest FALSELY assuming unpairedness}
testing_timepoints_fun <- function(data_named_timepoints,
                                   testing_fun,
                                   bind_format_reslist,
                                   verbose = TRUE,
                                   save_intermediate_file = "intermediate_data/res_rroc_test.RDS",
                                   ...) {
    res_rroc_test <- list()
    for (timepoint1 in names(data_named_timepoints)) {
        for (timepoint2 in names(data_named_timepoints)) {
            cat(timepoint1, timepoint2)
            if (timepoint1 == timepoint2) {
                cat("  skipped\n")
                next
            }
            cat("\n")
            data_tp1 <- data_named_timepoints[[timepoint1]]
            data_tp2 <- data_named_timepoints[[timepoint2]]
            if (!all(colnames(data_tp1) == colnames(data_tp2))) {
                stop("The order of the features is not the same in both matrices")
            }
            tmp_reslist <- list()
            for (feature in colnames(data_tp1[, -1])) {
                cat("  ", feature, "\n")
                if (!all(data_tp1[[1]] == data_tp2[[1]])) {
                    stop("The order of the samples is not the same in both matrices")
                }
                data_tp1_tp2 <- data.frame(
                    "tp1" = data_tp1[[feature]],
                    "tp2" = data_tp2[[feature]]
                )
                data_tp1_tp2_nona <- na.omit(data_tp1_tp2)
                if (nrow(data_tp1_tp2_nona) < 2) {
                    cat("    ", "Too few samples, skipping\n")
                    next
                }
                tmp_reslist[[feature]] <- testing_fun(
                    response = c(rep(timepoint1, nrow(data_tp1_tp2_nona)), rep(timepoint2, nrow(data_tp1_tp2_nona))),
                    predictor = c(data_tp1_tp2_nona[[1]], data_tp1_tp2_nona[[2]]),
                    positive_label = timepoint2,
                    ...
                )
                tmp_reslist[[feature]][["avg.FC"]] <- mean(data_tp1_tp2_nona[[2]]) - mean(data_tp1_tp2_nona[[1]])
            }
            res_rroc_test[[paste0(timepoint1, "_", timepoint2)]] <- bind_format_reslist(tmp_reslist)
            if (!is.na(save_intermediate_file)) {
                qs::qsave(res_rroc_test, file = save_intermediate_file)
            }
        }
    }
    return(res_rroc_test)
}

rroc_timepoints_fun <- function(data_named_timepoints,
                                verbose = TRUE,
                                n_permutations = 100,
                                save_intermediate_file = "intermediate_data/res_rroc_test.RDS",
                                ...) {
    return(
        testing_timepoints_fun(
            data_named_timepoints = data_named_timepoints,
            testing_fun = function(response, predictor, positive_label, ...) {
                return(restrictedROC::simple_rROC_permutation(
                    response = response,
                    predictor = predictor,
                    positive_label = positive_label,
                    n_permutations = n_permutations,
                    ...
                ))
            },
            bind_format_reslist = function(x) {
                tmp <- tibble::as_tibble(do.call(rbind, lapply(
                    x, function(x) {
                        return(c(
                            "max_neglog_p.value" = -log10(x$permutation_pval[["pval.twoside.max"]]),
                            "global_neglog_p.value" = -log10(x$permutation_pval[["pval.twoside.global"]]),
                            "max_p.value" = (x$permutation_pval[["pval.twoside.max"]]),
                            "global_p.value" = (x$permutation_pval[["pval.twoside.global"]]),
                            "avg.FC" = x[["avg.FC"]]
                        ))
                    }
                )))
                tmp[["max_q.value"]] <- p.adjust(tmp[["max_p.value"]], method = "BH")
                tmp[["global_q.value"]] <- p.adjust(tmp[["global_p.value"]], method = "BH")
                tmp[["feature"]] <- names(x)
                return(tmp)
            },
            verbose = verbose,
            save_intermediate_file = save_intermediate_file,
            ...
        )
    )
}

ttest_timepoints_fun <- function(data_named_timepoints,
                                 verbose = TRUE,
                                 save_intermediate_file = "intermediate_data/res_rroc_test.RDS",
                                 ...) {
    return(
        testing_timepoints_fun(
            data_named_timepoints = data_named_timepoints,
            testing_fun = function(response, predictor, positive_label, ...) {
                return(t.test(
                    x = predictor[response == positive_label],
                    y = predictor[response != positive_label],
                    ...
                ))
            },
            bind_format_reslist = function(x) {
                tmp <- tibble::as_tibble(do.call(rbind, lapply(
                    x, function(x) {
                        return(c(
                            "neglog_p.value" = -log10(x$p.value),
                            "p.value" = x$p.value,
                            "t" = x$statistic[[1]],
                            "avg.FC" = x[["avg.FC"]]
                        ))
                    }
                )))
                tmp[["q.value"]] <- p.adjust(tmp[["p.value"]], method = "BH")
                tmp[["negL10_q.value"]] <- -log10(tmp[["q.value"]])
                tmp[["feature"]] <- names(x)
                return(tmp)
            },
            verbose = verbose,
            save_intermediate_file = save_intermediate_file,
            ...
        )
    )
}
```

```{r, ttests }
# install.packages("qs")
li_all_data_ttests_paired <- lapply(
    li_all_data_measurements,
    ttest_timepoints_fun,
    save_intermediate_file = file.path(outdir, "res_t_test.qs"),
    paired = TRUE, var.equal = TRUE
)
li_all_data_ttests_unpaired <- lapply(
    li_all_data_measurements,
    ttest_timepoints_fun,
    save_intermediate_file = file.path(outdir, "res_t_test_unpaired.qs"),
    paired = FALSE, var.equal = TRUE
)
```

```{r, rroc}
library(future)
plan(multisession)
for (n_permutations in c(25000)) {
# for (n_permutations in c(3)) {
    li_all_data_rroc <- sapply(
        names(li_all_data_measurements),
        function(study_x) {
            resfile <- file.path(outdir, paste0("res_rroc_test_", n_permutations / 1000, "k_", study_x, ".qs"))
            cat("Starting ", resfile, "\n")
            if (file.exists(resfile)) {
                li_all_data_rroc <- qs::qread(resfile)
            } else {
                rroc_timepoints_fun(
                    li_all_data_measurements[[study_x]],
                    n_permutations = n_permutations,
                    parallel_permutations = TRUE,
                    save_intermediate_file = resfile
                )
            }
        }
    )
}
```

```{r, Fig 2}
pacman::p_load("ggplot2")
studies_clearnames <- dataMelanoma::li2019_studies_clearnames
named_figs <- list(
    "fig2a" = c("s1", "week 4", "baseline"),
    "fig2c" = c("s1", "week 6", "week 4"),
    "fig2d" = c("s3_nivo", "week 4", "baseline"),
    "fig2f" = c("s3_ever", "week 4", "baseline")
)
# pdf("removeme.pdf", width = 15, height = 4)
pdf(file.path(outdir, "fig2_redone.pdf"), width = 4, height = 15)
for (name_all in c(FALSE, TRUE)) {
    for (study_tp1_tp2_x in names(named_figs)) {
        study_tp1_tp2 <- named_figs[[study_tp1_tp2_x]]
        study_x <- study_tp1_tp2[[1]]
        tp1 <- study_tp1_tp2[[2]]
        tp2 <- study_tp1_tp2[[3]]

        plot_paper <- ggplot(
            li_all_data_ttests_paired[[study_x]][[paste0(tp1, "_", tp2)]],
            aes(x = avg.FC, y = negL10_q.value, label = feature)
        ) +
            ggtitle(study_tp1_tp2_x, subtitle = paste0("Paired t-test"))
        plot_paper_unpaired <- ggplot(
            li_all_data_ttests_unpaired[[study_x]][[paste0(tp1, "_", tp2)]],
            aes(x = avg.FC, y = negL10_q.value, label = feature)
        ) +
            ggtitle(study_tp1_tp2_x, subtitle = paste0("UNpaired t-test"))

        plot_permutation_global <- ggplot(
            li_all_data_rroc[[study_x]][[paste0(tp1, "_", tp2)]],
            aes(x = avg.FC, y = global_neglog_p.value, label = feature)
        ) +
            ggtitle(study_tp1_tp2_x, subtitle = paste0("Permutation test on AUC, global"))

        plot_permutation_max <- ggplot(
            li_all_data_rroc[[study_x]][[paste0(tp1, "_", tp2)]],
            aes(x = avg.FC, y = max_neglog_p.value, label = feature)
        ) +
            ggtitle(study_tp1_tp2_x, subtitle = paste0("Permutation test on AUC, Restriction"))

        plots_done <- lapply(list(
            plot_paper,
            plot_paper_unpaired,
            plot_permutation_global,
            plot_permutation_max
        ), function(x) {
            tmp <- x +
                geom_point() +
                ggpubr::theme_pubr()
            if (name_all) {
                tmp <- tmp + geom_text(size = 1, color = "darkgreen")
            } else {
                # tmp <- tmp + geom_text(
                #     data = subset(x$data, x$data[, x$labels$y] > -log10(0.05)),
                #     size = 1.5, color = "darkgreen"
                # )
                tmp <- tmp + ggrepel::geom_text_repel(
                    # tmp <- tmp + ggrepel::geom_label_repel(
                    data = subset(x$data, x$data[, x$labels$y] > -log10(0.05)),
                    size = 2, color = "darkgreen",
                    min.segment.length = 0, seed = 42, box.padding = 0.3,
                    max.overlaps = 10
                )
            }
            return(
                tmp +
                    xlab(paste0("Average fold change, ", tp1, " vs ", tp2, "\n", studies_clearnames[study_x])) +
                    ylab("-log10(q.value)") +
                    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
                    ylim(c(0, 12))
            )
        })
        print(patchwork::wrap_plots(plots_done, nrow = 4))
    }
}
dev.off()
```

```{r, Plot distribution of explicit features}
which_features <- list(
    "fig2a_restriction" = "guanidinoacetic acid",
    "fig2a_restriction" = "C14:1 carnitine",
    "fig2a_restriction" = "guanine",
    "fig2a_restriction" = "asparagine",
    "fig2c_restriction" = "hydroxyproline",
    "fig2c_restriction" = "C7 carnitine",
    "fig2c_restriction" = "3-hydroxyanthranilic acid"
)
pdf(file.path(outdir, "selected_features.pdf"), height = 15, width = 10)
for (f_i in seq_along(which_features)) {
    source_x <- names(which_features)[f_i]
    feature_x <- which_features[[f_i]]
    all_studies_plots <- list()
    for (study_tp1_tp2_x in names(named_figs)) {
        study_tp1_tp2 <- named_figs[[study_tp1_tp2_x]]
        study_x <- study_tp1_tp2[[1]]
        tp1 <- study_tp1_tp2[[2]]
        tp2 <- study_tp1_tp2[[3]]
        if (!feature_x %in% names(li_all_data_measurements[[study_x]][[tp1]])) {
            cat("Feature ", feature_x, " not in ", study_x, "\n")
            all_studies_plots[[study_tp1_tp2_x]] <- NA
        } else {
            data_tp1_tp2_noNA <- na.omit(
                data.frame(
                    "tp1" = li_all_data_measurements[[study_x]][[tp1]][[feature_x]],
                    "tp2" = li_all_data_measurements[[study_x]][[tp2]][[feature_x]]
                )
            )
            names(data_tp1_tp2_noNA) <- gsub(" ", "", c(tp1, tp2))
            feature_paired_ttest <- li_all_data_ttests_paired[[study_x]][[paste0(tp1, "_", tp2)]]
            feature_paired_ttest <- feature_paired_ttest[feature_paired_ttest$feature == feature_x, ]
            all_studies_plots[[study_tp1_tp2_x]] <- restrictedROC::plot_density_rROC_empirical(
                values_grouped = data_tp1_tp2_noNA,
                xmin = min(data_tp1_tp2_noNA),
                xmax = max(data_tp1_tp2_noNA)
            )[["plots"]]
        }
    }
    tmp <- lapply(names(all_studies_plots), function(plot_x) {
        x <- all_studies_plots[[plot_x]]
        if (all(is.na(x))) {
            return(NA)
        }
        patchwork::wrap_plots(list(x[[1]] +
            ggtitle(
                plot_x,
                studies_clearnames[named_figs[[plot_x]]]
            ), x[[3]]), nrow = 1)
    })
    tmp[is.na(tmp)] <- NULL
    print(
        patchwork::wrap_plots(tmp, nrow = 4) +
            patchwork::plot_annotation(title = paste(feature_x, "  source=", source_x))
    )
}
dev.off()
```


[1]: Li, H., Bullock, K., Gurjao, C. et al. Metabolomic adaptations and correlates of survival to immune checkpoint blockade. Nat Commun 10, 4346 (2019). https://doi.org/10.1038/s41467-019-12361-9
