---
title: "Datatypes 02: Metabolomics"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```




```{r setup}
options(warn = 1)
library(restrictedROC)
```

```{r download data, supplement 1}
library(dplyr)
dir.create("intermediate_data")
datasets <- paste0("https://static-content.springer.com/esm/art%3A10.1038%2Fs41467-019-12361-9/MediaObjects/41467_2019_12361_MOESM", 4:6, "_ESM.xlsx")
lapply(datasets, function(x) {
    download.file(
        url = x,
        destfile = paste0("intermediate_data/", basename(x))
    )
})
li_all_data <- sapply(basename(datasets), function(supplement_x) {
    sheets <- readxl::excel_sheets(paste0("intermediate_data/", basename(supplement_x)))
    x <- sapply(sheets, function(x) readxl::read_excel(paste0("intermediate_data/", supplement_x), sheet = x, na = "NA"))
    return(x[names(x) %in% c("patient characteristics", "baseline", "week 4", "week 6", "week 8")])
}, simplify = FALSE, USE.NAMES = TRUE)

names(li_all_data) <- c(
    "41467_2019_12361_MOESM4_ESM.xlsx" = "s1",
    "41467_2019_12361_MOESM5_ESM.xlsx" = "s2",
    "41467_2019_12361_MOESM6_ESM.xlsx" = "s3"
)[names(li_all_data)]

li_all_data$s3_nivo <- lapply(li_all_data$s3, function(x) {
    return(x[li_all_data[["s3"]][["patient characteristics"]][["Treatment"]] == "NIVOLUMAB", ])
})
li_all_data$s3_ever <- lapply(li_all_data$s3, function(x) {
    return(x[li_all_data[["s3"]][["patient characteristics"]][["Treatment"]] == "EVEROLIMUS", ])
})
li_all_data[["s3"]] <- NULL

li_all_data_measurements <- lapply(li_all_data, function(x) {
    x[["patient characteristics"]] <- NULL
    return(x)
})
```

```{r, ttest FALSELY assuming unpairedness}
testing_timepoints_fun <- function(data_named_timepoints,
                                   testing_fun,
                                   bind_format_reslist,
                                   verbose = TRUE,
                                   n_permutations = 100,
                                   save_intermediate_file = "intermediate_data/res_rroc_test.RDS",
                                   ...) {
    res_rroc_test <- list()
    for (timepoint1 in names(data_named_timepoints)) {
        for (timepoint2 in names(data_named_timepoints)) {
            cat(timepoint1, timepoint2)
            if (timepoint1 == timepoint2) {
                cat("  skipped\n")
                next
            }
            cat("\n")
            data_tp1 <- data_named_timepoints[[timepoint1]]
            data_tp2 <- data_named_timepoints[[timepoint2]]
            if (!all(colnames(data_tp1) == colnames(data_tp2))) {
                stop("The order of the features is not the same in both matrices")
            }
            tmp_reslist <- list()
            for (feature in colnames(data_tp1[, -1])) {
                cat("  ", feature, "\n")
                if (!all(data_tp1[[1]] == data_tp2[[1]])) {
                    stop("The order of the samples is not the same in both matrices")
                }
                data_tp1_tp2 <- data.frame(
                    "tp1" = data_tp1[[feature]],
                    "tp2" = data_tp2[[feature]]
                )
                data_tp1_tp2_nona <- na.omit(data_tp1_tp2)
                if (nrow(data_tp1_tp2_nona) < 2) {
                    cat("    ", "Too few samples, skipping\n")
                    next
                }
                # pdf(paste0("removeme", timepoint1, "_", timepoint2, ".pdf"))
                # print(
                #     restrictedROC::plot_density_rROC_empirical(values_grouped = data_tp1_tp2_nona)
                # )
                # dev.off()
                tmp_reslist[[feature]] <- testing_fun(
                    response = c(rep(timepoint1, nrow(data_tp1_tp2_nona)), rep(timepoint2, nrow(data_tp1_tp2_nona))),
                    predictor = c(data_tp1_tp2_nona[[1]], data_tp1_tp2_nona[[2]]),
                    positive_label = timepoint2,
                    ...
                )
                # rroc_res <- restrictedROC::simple_rROC_permutation(
                #     response = c(rep(timepoint1, nrow(data_tp1_tp2_nona)), rep(timepoint2, nrow(data_tp1_tp2_nona))),
                #     predictor = c(data_tp1_tp2_nona[[1]], data_tp1_tp2_nona[[2]]),
                #     n_permutations = n_permutations,
                #     positive_label = timepoint2,
                #     # parallel_permutations = FALSE
                #     parallel_permutations = TRUE
                # )
                tmp_reslist[[feature]][["avg.FC"]] <- mean(data_tp1_tp2_nona[[2]]) - mean(data_tp1_tp2_nona[[1]])
            }
            res_rroc_test[[paste0(timepoint1, "_", timepoint2)]] <- bind_format_reslist(tmp_reslist)
            # tmp_reslist_formatted <- tibble::as_tibble(do.call(rbind, lapply(
            #     tmp_reslist, function(x) {
            #         return(c(
            #             "max_neglog_p.value" = -log10(x$permutation_pval[["pval.twoside.max"]]),
            #             "global_neglog_p.value" = -log10(x$permutation_pval[["pval.twoside.global"]]),
            #             "max_p.value" = (x$permutation_pval[["pval.twoside.max"]]),
            #             "global_p.value" = (x$permutation_pval[["pval.twoside.global"]]),
            #             "avg.FC" = x[["avg.FC"]]
            #         ))
            #     }
            # )))
            # tmp_reslist_formatted[["max_q.value"]] <- p.adjust(tmp_reslist_formatted[["max_p.value"]], method = "BH")
            # tmp_reslist_formatted[["global_q.value"]] <- p.adjust(tmp_reslist_formatted[["global_p.value"]], method = "BH")
            # tmp_reslist_formatted[["feature"]] <- names(tmp_reslist)
            # res_rroc_test[[paste0(timepoint1, "_", timepoint2)]] <- list(tmp_reslist_formatted, tmp_reslist)
            if (!is.na(save_intermediate_file)) {
                qs::qsave(res_rroc_test, file = save_intermediate_file)
            }
        }
    }
    return(res_rroc_test)
}

rroc_timepoints_fun <- function(data_named_timepoints,
                                verbose = TRUE,
                                n_permutations = 100,
                                save_intermediate_file = "intermediate_data/res_rroc_test.RDS",
                                ...) {
    return(
        testing_timepoints_fun(
            data_named_timepoints = data_named_timepoints,
            testing_fun = function(response, predictor, positive_label, ...) {
                return(restrictedROC::simple_rROC_permutation(
                    response = response,
                    predictor = predictor,
                    positive_label = positive_label,
                    ...
                ))
            },
            bind_format_reslist = function(x) {
                tmp <- tibble::as_tibble(do.call(rbind, lapply(
                    x, function(x) {
                        return(c(
                            "max_neglog_p.value" = -log10(x$permutation_pval[["pval.twoside.max"]]),
                            "global_neglog_p.value" = -log10(x$permutation_pval[["pval.twoside.global"]]),
                            "max_p.value" = (x$permutation_pval[["pval.twoside.max"]]),
                            "global_p.value" = (x$permutation_pval[["pval.twoside.global"]]),
                            "avg.FC" = x[["avg.FC"]]
                        ))
                    }
                )))
                tmp[["max_q.value"]] <- p.adjust(tmp[["max_p.value"]], method = "BH")
                tmp[["global_q.value"]] <- p.adjust(tmp[["global_p.value"]], method = "BH")
                tmp[["feature"]] <- names(x)
                return(tmp)
            },
            verbose = verbose,
            n_permutations = n_permutations,
            save_intermediate_file = save_intermediate_file,
            ...
        )
    )
}

ttest_timepoints_fun <- function(data_named_timepoints,
                                 verbose = TRUE,
                                 save_intermediate_file = "intermediate_data/res_rroc_test.RDS",
                                 ...) {
    return(
        testing_timepoints_fun(
            data_named_timepoints = data_named_timepoints,
            testing_fun = function(response, predictor, positive_label, ...) {
                return(t.test(
                    x = predictor[response == positive_label],
                    y = predictor[response != positive_label],
                    ...
                ))
            },
            bind_format_reslist = function(x) {
                tmp <- tibble::as_tibble(do.call(rbind, lapply(
                    x, function(x) {
                        return(c(
                            "neglog_p.value" = -log10(x$p.value),
                            "p.value" = x$p.value,
                            "t" = x$statistic[[1]],
                            "avg.FC" = x[["avg.FC"]]
                        ))
                    }
                )))
                tmp[["q.value"]] <- p.adjust(tmp[["p.value"]], method = "BH")
                tmp[["negL10_q.value"]] <- -log10(tmp[["q.value"]])
                tmp[["feature"]] <- names(x)
                return(tmp)
            },
            verbose = verbose,
            save_intermediate_file = save_intermediate_file,
            ...
        )
    )
}
```

```{r, ttests }
# li_all_data_measurements
li_all_data_ttests <- lapply(
    li_all_data_measurements,
    ttest_timepoints_fun,
    save_intermediate_file = "intermediate_data/res_t_test.qrds"
)
```

```{r, rroc 1k}
library(future)
plan(multisession)
for (n_permutations in c(1000, 25000, 100000)) {
    print(n_permutations)
    li_all_data_rroc <- lapply(
        li_all_data_measurements,
        rroc_timepoints_fun,
        n_permutations = n_permutations,
        parallel_permutations = TRUE,
        save_intermediate_file = paste0("intermediate_data/res_rroc_test_", n_permutations / 1000, "k.qrds")
    )
}
```

```{r}
# ttest_timepoints_fun(li_all_data_measurements[[1]])

# res_rroc_li1 <- rroc_timepoints_fun(
#     data_named_timepoints = lapply(li_data_1, function(x) x[, c("Unique_Subject_Identifier", "hydroxyproline")])[c("w4", "w6")],
#     verbose = TRUE,
#     save_intermediate = "intermediate_data/res_rroc_li1.RDS",
#     n_permutations = 250
# )

# tmp <- lapply(li_data_1, function(x) x[, c("Unique_Subject_Identifier", "hydroxyproline")])[c("w4", "w6")]
# sum(!is.na(tmp[[1]][[2]]))
# lapply(res_rroc_li1, function(x) x[[1]])
# res_rroc_li1[["w6_w4"]][[2]]$hydroxyproline$perm_max_bound
# res_rroc_li1[["w6_w4"]][[2]]$hydroxyproline$perm_global_bound

# library(ggplot2)
# pdf("removeme.pdf")
# ggplot(res_rroc_li1[["w6_w4"]][[2]]$hydroxyproline$perm_max_bound, aes(x = rzAUC)) +
#     geom_histogram(bins = 100) +
#     geom_vline(xintercept = res_rroc_li1[["w6_w4"]][[2]]$hydroxyproline$max_total$rzAUC, color = "red", size = 1)
# dev.off()
# sum(abs(res_rroc_li1[["w6_w4"]][[2]]$hydroxyproline$perm_max_bound$rzAUC) > abs(res_rroc_li1[["w6_w4"]][[2]]$hydroxyproline$max_total$rzAUC))
# sum(abs(res_rroc_li1[["w4_w6"]][[2]]$hydroxyproline$perm_max_bound$rzAUC) > abs(res_rroc_li1[["w4_w6"]][[2]]$hydroxyproline$max_total$rzAUC))

# pdf("removeme.pdf")
# res_rroc_test <- list()
# for (timepoint1 in c("baseline", "w4", "w6")) {
#     for (timepoint2 in c("baseline", "w4", "w6")) {
#         cat(timepoint1, timepoint2, "\n")
#         if (timepoint1 == timepoint2) {
#             next
#         }
#         data_tp1 <- li_data_1[[timepoint1]]
#         data_tp2 <- li_data_1[[timepoint2]]
#         if (!all(colnames(data_tp1) == colnames(data_tp2))) {
#             stop("The order of the features is not the same in both matrices")
#         }
#         tmp_reslist <- list()
#         feature <- "tryptophan"
#         for (feature in colnames(data_tp1[, -1])) {
#             cat("  ", feature, "\n")
#             if (!all(data_tp1[[1]] == data_tp2[[1]])) {
#                 stop("The order of the samples is not the same in both matrices")
#             }
#             data_tp1_tp2 <- data.frame(
#                 "tp1" = data_tp1[[feature]],
#                 "tp2" = data_tp2[[feature]]
#             )
#             data_tp1_tp2_nona <- na.omit(data_tp1_tp2)
#             # pdf("removeme.pdf")
#             # restrictedROC::plot_density_rROC_empirical(values_grouped = data_tp1_tp2_nona)
#             # dev.off()
#             rroc_res <- restrictedROC::simple_rROC_permutation(
#                 response = c(rep(timepoint1, nrow(data_tp1_tp2_nona)), rep(timepoint2, nrow(data_tp1_tp2_nona))),
#                 predictor = c(data_tp1_tp2_nona[[1]], data_tp1_tp2_nona[[2]]),
#                 n_permutations = 2500,
#                 positive_label = timepoint2,
#                 # parallel_permutations = FALSE
#                 parallel_permutations = TRUE
#             )
#             print(rroc_res$permutation_pval)
#             tmp_reslist[[feature]] <- rroc_res
#             tmp_reslist[[feature]][["avg.FC"]] <- mean(data_tp1_tp2_nona[[2]]) - mean(data_tp1_tp2_nona[[1]])
#         }
#         tmp_reslist_formatted <- tibble::as_tibble(do.call(rbind, lapply(
#             tmp_reslist, function(x) {
#                 return(c(
#                     "max_neglog_p.value" = -log10(x$permutation_pval[["pval.twoside.max"]]),
#                     "global_neglog_p.value" = -log10(x$permutation_pval[["pval.twoside.global"]]),
#                     "max_p.value" = (x$permutation_pval[["pval.twoside.max"]]),
#                     "global_p.value" = (x$permutation_pval[["pval.twoside.global"]]),
#                     "avg.FC" = x[["avg.FC"]]
#                 ))
#             }
#         )))
#         tmp_reslist_formatted[["max_q.value"]] <- p.adjust(tmp_reslist_formatted[["max_p.value"]], method = "BH")
#         tmp_reslist_formatted[["global_q.value"]] <- p.adjust(tmp_reslist_formatted[["global_p.value"]], method = "BH")
#         tmp_reslist_formatted[["feature"]] <- names(tmp_reslist)
#         res_rroc_test[[paste0(timepoint1, "_", timepoint2)]] <- tmp_reslist_formatted
#         qs::qsave(res_rroc_test, file = "intermediate_data/res_rroc_test.RDS")
#     }
# }
# res_rroc_test <- qs::qread("intermediate_data/res_rroc_test.RDS")
# lapply(res_rroc_test, function(x) dplyr::arrange(x, max_p.value) |> head())
# lapply(res_rroc_test, function(x) dplyr::arrange(x, global_p.value) |> head())
# res_rroc_test[["baseline_w4"]] |>
#     dplyr::arrange(max_p.value) |>
#     head()
# res_rroc_test[["baseline_w4"]] |>
#     dplyr::arrange(max_p.value) |>
#     dplyr::pull(max_p.value) |>
#     p.adjust(method = "BH") |>
#     head()
# library(ggplot2)
# pdf("removeme.pdf")
# ggplot(res_rroc_test[["baseline_w4"]], aes(x = avg.FC, y = -log10(max_q.value), label = feature)) +
#     geom_point() +
#     # geom_text(size = 1) +
#     geom_hline(yintercept = -log10(0.05))
# dev.off()
```


[1]: Li, H., Bullock, K., Gurjao, C. et al. Metabolomic adaptations and correlates of survival to immune checkpoint blockade. Nat Commun 10, 4346 (2019). https://doi.org/10.1038/s41467-019-12361-9
