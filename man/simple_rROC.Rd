% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simple_rROC.R
\name{simple_rROC}
\alias{simple_rROC}
\title{restricted ROC}
\usage{
simple_rROC(
  response,
  predictor,
  direction = "<",
  positive_label = NULL,
  get_all_aucs_fun = get_all_aucs_norecalculation,
  return_proc = FALSE,
  do_parallel = FALSE,
  check_positive_negative_count = FALSE
)
}
\arguments{
\item{response}{A vector containing the true class labels. Care that it is VERY important
which class is the positive class because the \emph{predictions} are ordered according
to \code{restriction}}

\item{predictor}{A vector containing the predictions.}

\item{direction}{See \code{\link[pROC:roc]{pROC::roc()}}, but only "<" is implemented right now. Maybe changing the
positive_label already solves your problem.}

\item{positive_label}{Label for the positive class. All other values of \code{response} are regarded as negative cases.}

\item{get_all_aucs_fun}{How to calculate the AUCs. You would usually now want to set that.
Implemented are
\code{get_all_aucs()}:
Calculates the AUCs by actively splitting the data into markerHIGH
and markerLOW parts. Then calculates a usual AUC on the parts.

\if{html}{\out{<div class="sourceCode">}}\preformatted{    `get_all_aucs_norecalculation()`:
        Calculates the AUCs based on the scaling factor described in the
        publication. Much faster after the ROC curve does not have to
        be recalculated over and over again.
        Todo: Could potentially be improved by not recalculating the partial
        AUCs with pROC over and over but by just adding parts.
}\if{html}{\out{</div>}}}

\item{return_proc}{\enumerate{
\item Should pROC::roc() be returned for the full dataset?
2) Should pROC::roc() be returned on each of the part datasets? Only works with
\code{get_all_aucs_fun=get_all_aucs} after  \code{get_all_aucs_norecalculation()} does
not calculate the ROC curves for each restriction separately.
}}

\item{do_parallel}{\code{get_all_aucs()} has parallelization enabled, but for some reason it seemed
to not improve the speed of the calculation. Therefore throws an error.
\code{get_all_aucs_norecalculation()} does not use it at all.}

\item{check_positive_negative_count}{Pure checking/testing parameter, you would not set that TRUE anytime.
Just enables checks if the number of positives/negatives was extracted
correctly for the restrictions}
}
\value{
List of two elements:

\if{html}{\out{<div class="sourceCode">}}\preformatted{"positive_label": Label of the positive class
"joined_aucs": Table with the following columns:
 threshold
     The threshold which was used as restriction value.
     "high"-part is always >= threshold
     "low"-part is always   < threshold
 auc_high
     restricted AUC for the high part, including the scaling factor
 positives_high
     How many positives are in the restricted range of high values
 negatives_high
     How many negatives are in the restricted range of high values
 scaling_high
     Scaling factor which is multiplied with the actual partial
     area under the curve to obtain the "recalculated" area under
     the curve if it was RE-calculated on the samples being in the
     restricted range of high values
 auc_var_H0_high
     Estimated variance under the nullhypothesis using
     \deqn{\frac{n_{positives} + n_{negatives} + 1}{12\cdot n_{positives} \cdot n_{negatives}}}
 rzAUC_high
     restricted standardized AUC, obtained via
     \deqn{\frac{auc_high - .5}{\sqrt{auc_var_H0_high}}}
 pval_asym_onesided_high
     Asymptotic, onesided (is AUC bigger) p-value of the restricted standardized AUC,
     obtained via:
     \deqn{1 - pnorm(full_df[["rzAUC"]])}
     Here the requirements are not fullfilled, use with utmost caution!
 pval_asym_high
     Asymptotic, twosided (is AUC different) p-value of the restricted standardized AUC,
     obtained via:
     \deqn{(1 - pnorm(abs(full_df[["rzAUC"]]))) * 2}
     Here the requirements are not fullfilled, use with utmost caution!
 auc_low
     restricted AUC for the low part, including the scaling factor
 positives_low
     How many positives are in the restricted range of low values
 negatives_low
     How many negatives are in the restricted range of low values
 scaling_low
     Scaling factor which is multiplied with the actual partial
     area under the curve to obtain the "recalculated" area under
     the curve if it was RE-calculated on the samples being in the
     restricted range of low values
 auc_var_H0_low
     Estimated variance under the nullhypothesis using
     \deqn{\frac{n_{positives} + n_{negatives} + 1}{12\cdot n_{positives} \cdot n_{negatives}}}
 rzAUC_low
     restricted standardized AUC, obtained via
     \deqn{\frac{auc_low - .5}{\sqrt{auc_var_H0_low}}}
 pval_asym_onesided_low
     Asymptotic, onesided (is AUC bigger) p-value of the restricted standardized AUC,
     obtained via:
     \deqn{1 - pnorm(full_df[["rzAUC"]])}
     Here the requirements are not fullfilled, use with utmost caution!
 pval_asym_low
     Asymptotic, twosided (is AUC different) p-value of the restricted standardized AUC,
     obtained via:
     \deqn{(1 - pnorm(abs(full_df[["rzAUC"]]))) * 2}
     Here the requirements are not fullfilled, use with utmost caution!
 tp
     Number of true positives at that threshold including all samples
 fp
     Number of false positives at that threshold including all samples
 tpr_global
     True positive rate at that threshold including all ("global") samples
 fpr_global
     False positive rate at that threshold including all ("global") samples
}\if{html}{\out{</div>}}
}
\description{
Calculate the restricted ROC curves.
}
\examples{

data(aSAH, package = "pROC")
simple_rROC(
    response = aSAH$outcome,
    predictor = aSAH$ndka
)
simple_rROC(
    response = aSAH$outcome,
    predictor = aSAH$ndka,
    positive_label = "Poor"
)
simple_rROC(
    response = aSAH$outcome,
    predictor = aSAH$ndka,
    positive_label = "Good"
)
simple_rROC(
    response = aSAH$outcome,
    predictor = aSAH$ndka,
    get_all_aucs_fun = restrictedROC:::get_all_aucs_norecalculation
)
simple_rROC(
    response = aSAH$outcome,
    predictor = aSAH$ndka,
    get_all_aucs_fun = restrictedROC:::get_all_aucs
)
simple_rROC(
    response = aSAH$outcome,
    predictor = aSAH$ndka,
    get_all_aucs_fun = restrictedROC:::get_all_aucs,
    return_proc = TRUE
)
simple_rROC(
    response = aSAH$outcome,
    predictor = aSAH$ndka,
    check_positive_negative_count = TRUE
)
simple_rROC(
    response = aSAH$outcome,
    predictor = aSAH$ndka,
    do_parallel = TRUE
)
\dontrun{
simple_rROC(
    response = aSAH$outcome,
    predictor = aSAH$ndka,
    get_all_aucs_fun = restrictedROC:::get_all_aucs,
    do_parallel = TRUE
)
}
}
